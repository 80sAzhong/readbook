程序员修炼之道1-2章
处理问题、寻求解决方案时的态度、风格、哲学。
为你自己和你的行为负责这一中观念，是注重实效的哲学的一块基石。
第一章  注重实效的哲学
在所有弱点中，最大的弱点就是害怕暴露弱点
提供各种选择，而不要找蹩脚的借口。
不要容忍破窗户
做变化的催化剂
记住大图景
欲求更好，常把好事变糟（给用户以机会，让他们参与决定你所制作的东西何时已足够好）
使质量成为需求问题
知道何时止步(不要因为过度修饰和过于求精二损毁完好的程序，它不可能完美)
定期为你的资产投资
经营你的资产
定期投资
多元化
管理风险
低买高卖
*重新评估和平衡
目标
每年至少学习一种新语言
每季度阅读一本技术书籍
也要阅读非技术书籍
批判的思考
批判地分析你读到和听到的
交流
我相信被打量比被忽略要好
了解你的听众
选择时机
选择风格
让文档美观
让听众参与
做倾听者
回复他人
你说什么和你怎么说同样重要

第二章 注重实效的途径
重复的危害(不要在系统各处对知识进行重复)
DRY原则：(Don't Repeat Yourself不要重复你自己)
系统中的每一项知识都必须具有单一、无歧义、权威的标识
产生的原因:
强加的重复
信息的多种表示->编写简单的过滤器或代码生成器
代码中的文档->把注释保留给其他的高级说明
语言问题:在圆满中强加的重复
无意识的重复、
无耐性的重复
开发者之间的重复:多交流
让复用变得容易
正交性(不要把任何一项知识分散在多个系统组件中，解耦，互不依赖)，如果两个或多个事务中的一个发生变化，不影响其他事务，这些事务就是正交的。
消除无关事物之间的影响
设计自足的组件:独立、具有单一、良好定义的目的(内聚)。组件之间相互隔离。得到的好处就是：提高生产率与降低风险
项目团队
设计
工具箱与库
编码
与你的代码保持解耦；
编码使用全局数据
避免编码相似的函数
测试
文档
可撤销性(使你的项目与其不断变化的环境绝缘，制作灵活、有适应能力的软件)
 	如果某个想法是你惟一的想法，再没有什么比这个更危险的事情了。
不存在最终决策
灵活的架构
灵活、有适应新能力的软件

曳光弹(一种开发方式：同时搜集需求、测试设计、实现代码)
用曳光弹找到目标
用户能够及早看到能工作的东西
开发者构建一个他们能在其中工作的结构
你有一个集成平台
有可用于演示的东西
你讲更能够感觉到工作进展
曳光弹并非总能击中目标
原型制作生成用过就扔的代码，曳光弹代码虽然简约，但却是完整的，并且构成了最终系统的骨架一部分。可以把原型制作设为在第一发曳光弹发射之前进行的侦查和情报搜集工作。

原型与便签(使用原型来测试架构、算法、接口以及各种想法)
原型的设计目的就是回答一些问题。
应制作原型的事物
架构
已有系统中的新功能
外部数据的结构或内容
第三方工具或组件
性能问题
用户界面设计
原型制作是一种学习经验。
为了学习而制作原型
怎样使用原型
在构建原型时，可以忽略以下细节
正确性
完整性
健壮性
风格
原型应该是遮盖细节，并聚焦于所考虑系统的某些具体方面。
制作架构原型
主要组件的责任是否得到良好定义？是否适当？
主要组件间的协作是否得到良好定义？
耦合是否得以最小化
你能否确定重复的潜在来源？
接口定义和各项约束是否可以接受？
每个模块在执行过程中能否访问到所需要的数据？是否能在需要的时候进行访问？
怎样"不"使用原型

领域语言
语言的界限就是一个人的世界的界限
靠近问题领域编程
实现小型语言
数据语言与命令语言
数据语言产生某种形式的数据结构给应用使用，这些语言常用于表示配置信息。
独立语言与嵌入式语言
易于开发还是易于维护

估算
估算，以避免发生意外
估算来自哪里?以问题的模型为基础——》问已经做过这件事情的人
理解提问内容
建立系统的模型
给每个参数指定值
计算答案
追踪你的估算能力
估算项目进度
检查需求
分析风险
设计、实现、集成
向用户确认
通过代码对进度表进行迭代
